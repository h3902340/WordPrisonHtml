<!DOCTYPE html>
<meta charset="UTF-8">
<html>

<head>
    <title>文字脫出-第一關</title>
</head>

<body style="background-color:rgb(0, 0, 0);">
    <canvas id="mainCanvas" width="800" height="600" style="border:1px solid #d3d3d3;">
    </canvas>

    <script>
        var canvas = document.getElementById("mainCanvas");
        var ctx = canvas.getContext("2d");
        const dialogue_font_size = 30;
        ctx.font = `${dialogue_font_size}px Arial`;
        const type_interval = 40;
        const dialogue_width = 20;
        const dialogue_color = "#FFFFFF"
        const noun_color = "#FC9B45";
        const verb_color = "#51A6FF";
        const inventory_background_color = "#BEBEBE";
        const card_height = 50;
        const card_width_unit = 50;

        function getMousePos(canvas, event) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top,
            };
        }

        function isInside(pos, rect) {
            return pos.x > rect.x && pos.x < rect.x + rect.width && pos.y < rect.y + rect.height && pos.y > rect.y
        }

        function splitString(str, N) {
            const arr = [];

            for (let i = 0; i < str.length; i += N) {
                arr.push(str.substring(i, i + N));
            }

            return arr;
        }

        async function say(text) {
            let lineCount = 0;
            let wordCount = 0;
            textSplit = splitString(text, dialogue_width);
            for (let i = 0; i < textSplit.length; i++) {
                let currentText = textSplit[i];
                for (let j = 1; j <= currentText.length; j++) {
                    ctx.fillStyle = dialogue_color;
                    ctx.fillText(currentText.substr(0, j), 100, 100 + 35 * i);
                    await sleep(type_interval);
                }
            }
        }

        async function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        say("這裡是哪裡？「我」醒了過來。發現在自己被困在一間「密室」。我摸著自己的口袋，沒有找到手機，無法對外聯繫。但發現一張詞卡「檢視」。這是做什麼用的？（獲得「密室」、「我」、「檢視」）");

        let slotArray = [{
            x: 145,
            y: 270,
            width: 150,
            height: 50,
            isVerb: false,
            card: null
        }, {
            x: 325,
            y: 270,
            width: 150,
            height: 50,
            isVerb: true,
            card: null
        }, {
            x: 505,
            y: 270,
            width: 150,
            height: 50,
            isVerb: false,
            card: null
        }];

        let inventoryCardArray = [];

        function drawLevel() {
            ctx.clearRect(0,270, canvas.width, canvas.height);
            drawSlots();
            drawInventory();
        }

        // draw noun, verb, noun slots
        function drawSlots() {
            slotArray.forEach(slot => {
                ctx.beginPath();
                ctx.rect(slot.x, slot.y, slot.width, slot.height);
                ctx.lineWidth = 6;
                if (slot.isVerb) {
                    ctx.strokeStyle = verb_color;
                } else {
                    ctx.strokeStyle = noun_color;
                }
                ctx.stroke();
                if (slot.card) {
                    drawCardFromCenter(slot.card, slot.x + slot.width * .5, slot.y + slot.height * .5);
                }
            });
        }

        let inventoryTailX = 110;
        let inventoryTailY = 350;

        function drawInventory() {
            ctx.fillStyle = inventory_background_color;
            ctx.fillRect(100, 340, 600, 220);

            for (let i = 0; i < inventoryCardArray.length; i++) {
                if (inventoryCardArray[i].isSelected) continue;
                drawCardFromTopLeft(inventoryCardArray[i]);
            }
        }

        addCard("密室", false);
        addCard("我", false);
        addCard("檢視", true);

        // inventory functionality
        function addCard(word, isVerb) {
            let cardWidth = card_width_unit * word.length;
            let nextTailX = inventoryTailX + 10 + cardWidth;
            if (nextTailX > 600) {
                inventoryTailY += 10 + card_height;
            }
            inventoryCardArray.push({
                x: inventoryTailX,
                y: inventoryTailY,
                inventoryX: inventoryTailX,
                inventoryY: inventoryTailY,
                width: cardWidth,
                height: card_height,
                word: word,
                isVerb: isVerb,
                isSelected: false
            });
            inventoryTailX = inventoryTailX + cardWidth + 10;
        }

        canvas.addEventListener('click', function (evt) {
            var mousePos = getMousePos(canvas, evt);
            inventoryCardArray.forEach(card => {
                if (!isInside(mousePos, card)) return;
                let needToRedrawLevel = false;
                if (card.isSelected) {
                    card.x = card.inventoryX;
                    card.y = card.inventoryY;
                    card.isSelected = false;
                    for(let i = 0; i < slotArray.length; i++){
                        if(slotArray[i].card == card){
                            slotArray[i].card = null;
                            break;
                        }
                    }
                    needToRedrawLevel = true;
                } else {
                    for(let i = 0; i < slotArray.length; i++){
                        let slot = slotArray[i];
                        if(slot.isVerb == card.isVerb){
                            if(!slot.card){
                                slot.card = card;
                                card.isSelected = true;
                                card.x = slot.x + (slot.width - card.width) * .5;
                                card.y = slot.y;
                                needToRedrawLevel = true;
                                break;
                            }
                        }
                    }
                }

                if (needToRedrawLevel) {
                    drawLevel();
                }
            });
        });

        function drawCardFromTopLeft(card) {
            if (card.isVerb) {
                ctx.fillStyle = verb_color;
            } else {
                ctx.fillStyle = noun_color;
            }
            let cardWidth = 50 * card.word.length;
            ctx.fillRect(card.x, card.y, cardWidth, card_height);
            ctx.fillStyle = dialogue_color;
            ctx.fillText(card.word, card.x + (cardWidth - dialogue_font_size * card.word.length) * .5, card.y + 35);
        }

        function drawCardFromCenter(card, centerX, centerY) {
            if (card.isVerb) {
                ctx.fillStyle = verb_color;
            } else {
                ctx.fillStyle = noun_color;
            }
            let cardWidth = 50 * card.word.length;
            let x = centerX - cardWidth * .5;
            let y = centerY - card_height * .5;
            ctx.fillRect(x, y, cardWidth, card_height);
            ctx.fillStyle = dialogue_color;
            ctx.fillText(card.word, x + (cardWidth - dialogue_font_size * card.word.length) * .5, y + 35);
        }

        drawLevel();

    </script>

</body>

</html>